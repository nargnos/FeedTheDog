def GetData():
    data={'String': [{'Group': 'String', 'Cmd': 'APPEND', 'Args': 'key value', 'Summary': 'Append a value to a key', 'Name': 'Append'}, {'Group': 'String', 'Cmd': 'BITCOUNT', 'Args': 'key [start end]', 'Summary': 'Count set bits in a string', 'Name': 'Bitcount'}, {'Group': 'String', 'Cmd': 'BITFIELD', 'Args': 'key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]', 'Summary': 'Perform arbitrary bitfield integer operations on strings', 'Name': 'Bitfield'}, {'Group': 'String', 'Cmd': 'BITOP', 'Args': 'operation destkey key [key ...]', 'Summary': 'Perform bitwise operations between strings', 'Name': 'Bitop'}, {'Group': 'String', 'Cmd': 'BITPOS', 'Args': 'key bit [start] [end]', 'Summary': 'Find first bit set or clear in a string', 'Name': 'Bitpos'}, {'Group': 'String', 'Cmd': 'DECR', 'Args': 'key', 'Summary': 'Decrement the integer value of a key by one', 'Name': 'Decr'}, {'Group': 'String', 'Cmd': 'DECRBY', 'Args': 'key decrement', 'Summary': 'Decrement the integer value of a key by the given number', 'Name': 'Decrby'}, {'Group': 'String', 'Cmd': 'GET', 'Args': 'key', 'Summary': 'Get the value of a key', 'Name': 'Get'}, {'Group': 'String', 'Cmd': 'GETBIT', 'Args': 'key offset', 'Summary': 'Returns the bit value at offset in the string value stored at key', 'Name': 'Getbit'}, {'Group': 'String', 'Cmd': 'GETRANGE', 'Args': 'key start end', 'Summary': 'Get a substring of the string stored at a key', 'Name': 'Getrange'}, {'Group': 'String', 'Cmd': 'GETSET', 'Args': 'key value', 'Summary': 'Set the string value of a key and return its old value', 'Name': 'Getset'}, {'Group': 'String', 'Cmd': 'INCR', 'Args': 'key', 'Summary': 'Increment the integer value of a key by one', 'Name': 'Incr'}, {'Group': 'String', 'Cmd': 'INCRBY', 'Args': 'key increment', 'Summary': 'Increment the integer value of a key by the given amount', 'Name': 'Incrby'}, {'Group': 'String', 'Cmd': 'INCRBYFLOAT', 'Args': 'key increment', 'Summary': 'Increment the float value of a key by the given amount', 'Name': 'Incrbyfloat'}, {'Group': 'String', 'Cmd': 'MGET', 'Args': 'key [key ...]', 'Summary': 'Get the values of all the given keys', 'Name': 'Mget'}, {'Group': 'String', 'Cmd': 'MSET', 'Args': 'key value [key value ...]', 'Summary': 'Set multiple keys to multiple values', 'Name': 'Mset'}, {'Group': 'String', 'Cmd': 'MSETNX', 'Args': 'key value [key value ...]', 'Summary': 'Set multiple keys to multiple values, only if none of the keys exist', 'Name': 'Msetnx'}, {'Group': 'String', 'Cmd': 'PSETEX', 'Args': 'key milliseconds value', 'Summary': 'Set the value and expiration in milliseconds of a key', 'Name': 'Psetex'}, {'Group': 'String', 'Cmd': 'SET', 'Args': 'key value [EX seconds] [PX milliseconds] [NX|XX]', 'Summary': 'Set the string value of a key', 'Name': 'Set'}, {'Group': 'String', 'Cmd': 'SETBIT', 'Args': 'key offset value', 'Summary': 'Sets or clears the bit at offset in the string value stored at key', 'Name': 'Setbit'}, {'Group': 'String', 'Cmd': 'SETEX', 'Args': 'key seconds value', 'Summary': 'Set the value and expiration of a key', 'Name': 'Setex'}, {'Group': 'String', 'Cmd': 'SETNX', 'Args': 'key value', 'Summary': 'Set the value of a key, only if the key does not exist', 'Name': 'Setnx'}, {'Group': 'String', 'Cmd': 'SETRANGE', 'Args': 'key offset value', 'Summary': 'Overwrite part of a string at key starting at the specified offset', 'Name': 'Setrange'}, {'Group': 'String', 'Cmd': 'STRLEN', 'Args': 'key', 'Summary': 'Get the length of the value stored in a key', 'Name': 'Strlen'}], 'Connection': [{'Group': 'Connection', 'Cmd': 'AUTH', 'Args': 'password', 'Summary': 'Authenticate to the server', 'Name': 'Auth'}, {'Group': 'Connection', 'Cmd': 'ECHO', 'Args': 'message', 'Summary': 'Echo the given string', 'Name': 'Echo'}, {'Group': 'Connection', 'Cmd': 'PING', 'Args': '[message]', 'Summary': 'Ping the server', 'Name': 'Ping'}, {'Group': 'Connection', 'Cmd': 'QUIT', 'Args': '', 'Summary': 'Close the connection', 'Name': 'Quit'}, {'Group': 'Connection', 'Cmd': 'SELECT', 'Args': 'index', 'Summary': 'Change the selected database for the current connection', 'Name': 'Select'}, {'Group': 'Connection', 'Cmd': 'SWAPDB', 'Args': 'index index', 'Summary': 'Swaps two Redis databases', 'Name': 'Swapdb'}], 'Server': [{'Group': 'Server', 'Cmd': 'BGREWRITEAOF', 'Args': '', 'Summary': 'Asynchronously rewrite the append-only file', 'Name': 'Bgrewriteaof'}, {'Group': 'Server', 'Cmd': 'BGSAVE', 'Args': '', 'Summary': 'Asynchronously save the dataset to disk', 'Name': 'Bgsave'}, {'Group': 'Server', 'Cmd': 'CLIENT KILL', 'Args': '[ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]', 'Summary': 'Kill the connection of a client', 'Name': 'ClientKill'}, {'Group': 'Server', 'Cmd': 'CLIENT LIST', 'Args': '', 'Summary': 'Get the list of client connections', 'Name': 'ClientList'}, {'Group': 'Server', 'Cmd': 'CLIENT GETNAME', 'Args': '', 'Summary': 'Get the current connection name', 'Name': 'ClientGetname'}, {'Group': 'Server', 'Cmd': 'CLIENT PAUSE', 'Args': 'timeout', 'Summary': 'Stop processing commands from clients for some time', 'Name': 'ClientPause'}, {'Group': 'Server', 'Cmd': 'CLIENT REPLY', 'Args': 'ON|OFF|SKIP', 'Summary': 'Instruct the server whether to reply to commands', 'Name': 'ClientReply'}, {'Group': 'Server', 'Cmd': 'CLIENT SETNAME', 'Args': 'connection-name', 'Summary': 'Set the current connection name', 'Name': 'ClientSetname'}, {'Group': 'Server', 'Cmd': 'COMMAND', 'Args': '', 'Summary': 'Get array of Redis command details', 'Name': 'Command'}, {'Group': 'Server', 'Cmd': 'COMMAND COUNT', 'Args': '', 'Summary': 'Get total number of Redis commands', 'Name': 'CommandCount'}, {'Group': 'Server', 'Cmd': 'COMMAND GETKEYS', 'Args': '', 'Summary': 'Extract keys given a full Redis command', 'Name': 'CommandGetkeys'}, {'Group': 'Server', 'Cmd': 'COMMAND INFO', 'Args': 'command-name [command-name ...]', 'Summary': 'Get array of specific Redis command details', 'Name': 'CommandInfo'}, {'Group': 'Server', 'Cmd': 'CONFIG GET', 'Args': 'parameter', 'Summary': 'Get the value of a configuration parameter', 'Name': 'ConfigGet'}, {'Group': 'Server', 'Cmd': 'CONFIG REWRITE', 'Args': '', 'Summary': 'Rewrite the configuration file with the in memory configuration', 'Name': 'ConfigRewrite'}, {'Group': 'Server', 'Cmd': 'CONFIG SET', 'Args': 'parameter value', 'Summary': 'Set a configuration parameter to the given value', 'Name': 'ConfigSet'}, {'Group': 'Server', 'Cmd': 'CONFIG RESETSTAT', 'Args': '', 'Summary': 'Reset the stats returned by INFO', 'Name': 'ConfigResetstat'}, {'Group': 'Server', 'Cmd': 'DBSIZE', 'Args': '', 'Summary': 'Return the number of keys in the selected database', 'Name': 'Dbsize'}, {'Group': 'Server', 'Cmd': 'DEBUG OBJECT', 'Args': 'key', 'Summary': 'Get debugging information about a key', 'Name': 'DebugObject'}, {'Group': 'Server', 'Cmd': 'DEBUG SEGFAULT', 'Args': '', 'Summary': 'Make the server crash', 'Name': 'DebugSegfault'}, {'Group': 'Server', 'Cmd': 'FLUSHALL', 'Args': '[ASYNC]', 'Summary': 'Remove all keys from all databases', 'Name': 'Flushall'}, {'Group': 'Server', 'Cmd': 'FLUSHDB', 'Args': '[ASYNC]', 'Summary': 'Remove all keys from the current database', 'Name': 'Flushdb'}, {'Group': 'Server', 'Cmd': 'INFO', 'Args': '[section]', 'Summary': 'Get information and statistics about the server', 'Name': 'Info'}, {'Group': 'Server', 'Cmd': 'LASTSAVE', 'Args': '', 'Summary': 'Get the UNIX time stamp of the last successful save to disk', 'Name': 'Lastsave'}, {'Group': 'Server', 'Cmd': 'MONITOR', 'Args': '', 'Summary': 'Listen for all requests received by the server in real time', 'Name': 'Monitor'}, {'Group': 'Server', 'Cmd': 'ROLE', 'Args': '', 'Summary': 'Return the role of the instance in the context of replication', 'Name': 'Role'}, {'Group': 'Server', 'Cmd': 'SAVE', 'Args': '', 'Summary': 'Synchronously save the dataset to disk', 'Name': 'Save'}, {'Group': 'Server', 'Cmd': 'SHUTDOWN', 'Args': '[NOSAVE|SAVE]', 'Summary': 'Synchronously save the dataset to disk and then shut down the server', 'Name': 'Shutdown'}, {'Group': 'Server', 'Cmd': 'SLAVEOF', 'Args': 'host port', 'Summary': 'Make the server a slave of another instance, or promote it as master', 'Name': 'Slaveof'}, {'Group': 'Server', 'Cmd': 'SLOWLOG', 'Args': 'subcommand [argument]', 'Summary': 'Manages the Redis slow queries log', 'Name': 'Slowlog'}, {'Group': 'Server', 'Cmd': 'SYNC', 'Args': '', 'Summary': 'Internal command used for replication', 'Name': 'Sync'}, {'Group': 'Server', 'Cmd': 'TIME', 'Args': '', 'Summary': 'Return the current server time', 'Name': 'Time'}], 'List': [{'Group': 'List', 'Cmd': 'BLPOP', 'Args': 'key [key ...] timeout', 'Summary': 'Remove and get the first element in a list, or block until one is available', 'Name': 'Blpop'}, {'Group': 'List', 'Cmd': 'BRPOP', 'Args': 'key [key ...] timeout', 'Summary': 'Remove and get the last element in a list, or block until one is available', 'Name': 'Brpop'}, {'Group': 'List', 'Cmd': 'BRPOPLPUSH', 'Args': 'source destination timeout', 'Summary': 'Pop a value from a list, push it to another list and return it; or block until one is available', 'Name': 'Brpoplpush'}, {'Group': 'List', 'Cmd': 'LINDEX', 'Args': 'key index', 'Summary': 'Get an element from a list by its index', 'Name': 'Lindex'}, {'Group': 'List', 'Cmd': 'LINSERT', 'Args': 'key BEFORE|AFTER pivot value', 'Summary': 'Insert an element before or after another element in a list', 'Name': 'Linsert'}, {'Group': 'List', 'Cmd': 'LLEN', 'Args': 'key', 'Summary': 'Get the length of a list', 'Name': 'Llen'}, {'Group': 'List', 'Cmd': 'LPOP', 'Args': 'key', 'Summary': 'Remove and get the first element in a list', 'Name': 'Lpop'}, {'Group': 'List', 'Cmd': 'LPUSH', 'Args': 'key value [value ...]', 'Summary': 'Prepend one or multiple values to a list', 'Name': 'Lpush'}, {'Group': 'List', 'Cmd': 'LPUSHX', 'Args': 'key value', 'Summary': 'Prepend a value to a list, only if the list exists', 'Name': 'Lpushx'}, {'Group': 'List', 'Cmd': 'LRANGE', 'Args': 'key start stop', 'Summary': 'Get a range of elements from a list', 'Name': 'Lrange'}, {'Group': 'List', 'Cmd': 'LREM', 'Args': 'key count value', 'Summary': 'Remove elements from a list', 'Name': 'Lrem'}, {'Group': 'List', 'Cmd': 'LSET', 'Args': 'key index value', 'Summary': 'Set the value of an element in a list by its index', 'Name': 'Lset'}, {'Group': 'List', 'Cmd': 'LTRIM', 'Args': 'key start stop', 'Summary': 'Trim a list to the specified range', 'Name': 'Ltrim'}, {'Group': 'List', 'Cmd': 'RPOP', 'Args': 'key', 'Summary': 'Remove and get the last element in a list', 'Name': 'Rpop'}, {'Group': 'List', 'Cmd': 'RPOPLPUSH', 'Args': 'source destination', 'Summary': 'Remove the last element in a list, prepend it to another list and return it', 'Name': 'Rpoplpush'}, {'Group': 'List', 'Cmd': 'RPUSH', 'Args': 'key value [value ...]', 'Summary': 'Append one or multiple values to a list', 'Name': 'Rpush'}, {'Group': 'List', 'Cmd': 'RPUSHX', 'Args': 'key value', 'Summary': 'Append a value to a list, only if the list exists', 'Name': 'Rpushx'}], 'Cluster': [{'Group': 'Cluster', 'Cmd': 'CLUSTER ADDSLOTS', 'Args': 'slot [slot ...]', 'Summary': 'Assign new hash slots to receiving node', 'Name': 'ClusterAddslots'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER COUNT-FAILURE-REPORTS', 'Args': 'node-id', 'Summary': 'Return the number of failure reports active for a given node', 'Name': 'ClusterCountFailureReports'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER COUNTKEYSINSLOT', 'Args': 'slot', 'Summary': 'Return the number of local keys in the specified hash slot', 'Name': 'ClusterCountkeysinslot'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER DELSLOTS', 'Args': 'slot [slot ...]', 'Summary': 'Set hash slots as unbound in receiving node', 'Name': 'ClusterDelslots'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER FAILOVER', 'Args': '[FORCE|TAKEOVER]', 'Summary': 'Forces a slave to perform a manual failover of its master.', 'Name': 'ClusterFailover'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER FORGET', 'Args': 'node-id', 'Summary': 'Remove a node from the nodes table', 'Name': 'ClusterForget'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER GETKEYSINSLOT', 'Args': 'slot count', 'Summary': 'Return local key names in the specified hash slot', 'Name': 'ClusterGetkeysinslot'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER INFO', 'Args': '', 'Summary': 'Provides info about Redis Cluster node state', 'Name': 'ClusterInfo'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER KEYSLOT', 'Args': 'key', 'Summary': 'Returns the hash slot of the specified key', 'Name': 'ClusterKeyslot'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER MEET', 'Args': 'ip port', 'Summary': 'Force a node cluster to handshake with another node', 'Name': 'ClusterMeet'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER NODES', 'Args': '', 'Summary': 'Get Cluster config for the node', 'Name': 'ClusterNodes'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER REPLICATE', 'Args': 'node-id', 'Summary': 'Reconfigure a node as a slave of the specified master node', 'Name': 'ClusterReplicate'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER RESET', 'Args': '[HARD|SOFT]', 'Summary': 'Reset a Redis Cluster node', 'Name': 'ClusterReset'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER SAVECONFIG', 'Args': '', 'Summary': 'Forces the node to save cluster state on disk', 'Name': 'ClusterSaveconfig'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER SET-CONFIG-EPOCH', 'Args': 'config-epoch', 'Summary': 'Set the configuration epoch in a new node', 'Name': 'ClusterSetConfigEpoch'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER SETSLOT', 'Args': 'slot IMPORTING|MIGRATING|STABLE|NODE [node-id]', 'Summary': 'Bind a hash slot to a specific node', 'Name': 'ClusterSetslot'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER SLAVES', 'Args': 'node-id', 'Summary': 'List slave nodes of the specified master node', 'Name': 'ClusterSlaves'}, {'Group': 'Cluster', 'Cmd': 'CLUSTER SLOTS', 'Args': '', 'Summary': 'Get array of Cluster slot to node mappings', 'Name': 'ClusterSlots'}, {'Group': 'Cluster', 'Cmd': 'READONLY', 'Args': '', 'Summary': 'Enables read queries for a connection to a cluster slave node', 'Name': 'Readonly'}, {'Group': 'Cluster', 'Cmd': 'READWRITE', 'Args': '', 'Summary': 'Disables read queries for a connection to a cluster slave node', 'Name': 'Readwrite'}], 'Generic': [{'Group': 'Generic', 'Cmd': 'DEL', 'Args': 'key [key ...]', 'Summary': 'Delete a key', 'Name': 'Del'}, {'Group': 'Generic', 'Cmd': 'DUMP', 'Args': 'key', 'Summary': 'Return a serialized version of the value stored at the specified key.', 'Name': 'Dump'}, {'Group': 'Generic', 'Cmd': 'EXISTS', 'Args': 'key [key ...]', 'Summary': 'Determine if a key exists', 'Name': 'Exists'}, {'Group': 'Generic', 'Cmd': 'EXPIRE', 'Args': 'key seconds', 'Summary': "Set a key's time to live in seconds", 'Name': 'Expire'}, {'Group': 'Generic', 'Cmd': 'EXPIREAT', 'Args': 'key timestamp', 'Summary': 'Set the expiration for a key as a UNIX timestamp', 'Name': 'Expireat'}, {'Group': 'Generic', 'Cmd': 'KEYS', 'Args': 'pattern', 'Summary': 'Find all keys matching the given pattern', 'Name': 'Keys'}, {'Group': 'Generic', 'Cmd': 'MIGRATE', 'Args': 'host port key|"" destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]', 'Summary': 'Atomically transfer a key from a Redis instance to another one.', 'Name': 'Migrate'}, {'Group': 'Generic', 'Cmd': 'MOVE', 'Args': 'key db', 'Summary': 'Move a key to another database', 'Name': 'Move'}, {'Group': 'Generic', 'Cmd': 'OBJECT', 'Args': 'subcommand [arguments [arguments ...]]', 'Summary': 'Inspect the internals of Redis objects', 'Name': 'Object'}, {'Group': 'Generic', 'Cmd': 'PERSIST', 'Args': 'key', 'Summary': 'Remove the expiration from a key', 'Name': 'Persist'}, {'Group': 'Generic', 'Cmd': 'PEXPIRE', 'Args': 'key milliseconds', 'Summary': "Set a key's time to live in milliseconds", 'Name': 'Pexpire'}, {'Group': 'Generic', 'Cmd': 'PEXPIREAT', 'Args': 'key milliseconds-timestamp', 'Summary': 'Set the expiration for a key as a UNIX timestamp specified in milliseconds', 'Name': 'Pexpireat'}, {'Group': 'Generic', 'Cmd': 'PTTL', 'Args': 'key', 'Summary': 'Get the time to live for a key in milliseconds', 'Name': 'Pttl'}, {'Group': 'Generic', 'Cmd': 'RANDOMKEY', 'Args': '', 'Summary': 'Return a random key from the keyspace', 'Name': 'Randomkey'}, {'Group': 'Generic', 'Cmd': 'RENAME', 'Args': 'key newkey', 'Summary': 'Rename a key', 'Name': 'Rename'}, {'Group': 'Generic', 'Cmd': 'RENAMENX', 'Args': 'key newkey', 'Summary': 'Rename a key, only if the new key does not exist', 'Name': 'Renamenx'}, {'Group': 'Generic', 'Cmd': 'RESTORE', 'Args': 'key ttl serialized-value [REPLACE]', 'Summary': 'Create a key using the provided serialized value, previously obtained using DUMP.', 'Name': 'Restore'}, {'Group': 'Generic', 'Cmd': 'SORT', 'Args': 'key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]', 'Summary': 'Sort the elements in a list, set or sorted set', 'Name': 'Sort'}, {'Group': 'Generic', 'Cmd': 'TOUCH', 'Args': 'key [key ...]', 'Summary': 'Alters the last access time of a key(s). Returns the number of existing keys specified.', 'Name': 'Touch'}, {'Group': 'Generic', 'Cmd': 'TTL', 'Args': 'key', 'Summary': 'Get the time to live for a key', 'Name': 'Ttl'}, {'Group': 'Generic', 'Cmd': 'TYPE', 'Args': 'key', 'Summary': 'Determine the type stored at key', 'Name': 'Type'}, {'Group': 'Generic', 'Cmd': 'UNLINK', 'Args': 'key [key ...]', 'Summary': 'Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.', 'Name': 'Unlink'}, {'Group': 'Generic', 'Cmd': 'WAIT', 'Args': 'numslaves timeout', 'Summary': 'Wait for the synchronous replication of all the write commands sent in the context of the current connection', 'Name': 'Wait'}, {'Group': 'Generic', 'Cmd': 'SCAN', 'Args': 'cursor [MATCH pattern] [COUNT count]', 'Summary': 'Incrementally iterate the keys space', 'Name': 'Scan'}], 'Transactions': [{'Group': 'Transactions', 'Cmd': 'DISCARD', 'Args': '', 'Summary': 'Discard all commands issued after MULTI', 'Name': 'Discard'}, {'Group': 'Transactions', 'Cmd': 'EXEC', 'Args': '', 'Summary': 'Execute all commands issued after MULTI', 'Name': 'Exec'}, {'Group': 'Transactions', 'Cmd': 'MULTI', 'Args': '', 'Summary': 'Mark the start of a transaction block', 'Name': 'Multi'}, {'Group': 'Transactions', 'Cmd': 'UNWATCH', 'Args': '', 'Summary': 'Forget about all watched keys', 'Name': 'Unwatch'}, {'Group': 'Transactions', 'Cmd': 'WATCH', 'Args': 'key [key ...]', 'Summary': 'Watch the given keys to determine execution of the MULTI/EXEC block', 'Name': 'Watch'}], 'Scripting': [{'Group': 'Scripting', 'Cmd': 'EVAL', 'Args': 'script numkeys key [key ...] arg [arg ...]', 'Summary': 'Execute a Lua script server side', 'Name': 'Eval'}, {'Group': 'Scripting', 'Cmd': 'EVALSHA', 'Args': 'sha1 numkeys key [key ...] arg [arg ...]', 'Summary': 'Execute a Lua script server side', 'Name': 'Evalsha'}, {'Group': 'Scripting', 'Cmd': 'SCRIPT DEBUG', 'Args': 'YES|SYNC|NO', 'Summary': 'Set the debug mode for executed scripts.', 'Name': 'ScriptDebug'}, {'Group': 'Scripting', 'Cmd': 'SCRIPT EXISTS', 'Args': 'sha1 [sha1 ...]', 'Summary': 'Check existence of scripts in the script cache.', 'Name': 'ScriptExists'}, {'Group': 'Scripting', 'Cmd': 'SCRIPT FLUSH', 'Args': '', 'Summary': 'Remove all the scripts from the script cache.', 'Name': 'ScriptFlush'}, {'Group': 'Scripting', 'Cmd': 'SCRIPT KILL', 'Args': '', 'Summary': 'Kill the script currently in execution.', 'Name': 'ScriptKill'}, {'Group': 'Scripting', 'Cmd': 'SCRIPT LOAD', 'Args': 'script', 'Summary': 'Load the specified Lua script into the script cache.', 'Name': 'ScriptLoad'}], 'Geo': [{'Group': 'Geo', 'Cmd': 'GEOADD', 'Args': 'key longitude latitude member [longitude latitude member ...]', 'Summary': 'Add one or more geospatial items in the geospatial index represented using a sorted set', 'Name': 'Geoadd'}, {'Group': 'Geo', 'Cmd': 'GEOHASH', 'Args': 'key member [member ...]', 'Summary': 'Returns members of a geospatial index as standard geohash strings', 'Name': 'Geohash'}, {'Group': 'Geo', 'Cmd': 'GEOPOS', 'Args': 'key member [member ...]', 'Summary': 'Returns longitude and latitude of members of a geospatial index', 'Name': 'Geopos'}, {'Group': 'Geo', 'Cmd': 'GEODIST', 'Args': 'key member1 member2 [unit]', 'Summary': 'Returns the distance between two members of a geospatial index', 'Name': 'Geodist'}, {'Group': 'Geo', 'Cmd': 'GEORADIUS', 'Args': 'key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]', 'Summary': 'Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point', 'Name': 'Georadius'}, {'Group': 'Geo', 'Cmd': 'GEORADIUSBYMEMBER', 'Args': 'key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]', 'Summary': 'Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member', 'Name': 'Georadiusbymember'}], 'Hash': [{'Group': 'Hash', 'Cmd': 'HDEL', 'Args': 'key field [field ...]', 'Summary': 'Delete one or more hash fields', 'Name': 'Hdel'}, {'Group': 'Hash', 'Cmd': 'HEXISTS', 'Args': 'key field', 'Summary': 'Determine if a hash field exists', 'Name': 'Hexists'}, {'Group': 'Hash', 'Cmd': 'HGET', 'Args': 'key field', 'Summary': 'Get the value of a hash field', 'Name': 'Hget'}, {'Group': 'Hash', 'Cmd': 'HGETALL', 'Args': 'key', 'Summary': 'Get all the fields and values in a hash', 'Name': 'Hgetall'}, {'Group': 'Hash', 'Cmd': 'HINCRBY', 'Args': 'key field increment', 'Summary': 'Increment the integer value of a hash field by the given number', 'Name': 'Hincrby'}, {'Group': 'Hash', 'Cmd': 'HINCRBYFLOAT', 'Args': 'key field increment', 'Summary': 'Increment the float value of a hash field by the given amount', 'Name': 'Hincrbyfloat'}, {'Group': 'Hash', 'Cmd': 'HKEYS', 'Args': 'key', 'Summary': 'Get all the fields in a hash', 'Name': 'Hkeys'}, {'Group': 'Hash', 'Cmd': 'HLEN', 'Args': 'key', 'Summary': 'Get the number of fields in a hash', 'Name': 'Hlen'}, {'Group': 'Hash', 'Cmd': 'HMGET', 'Args': 'key field [field ...]', 'Summary': 'Get the values of all the given hash fields', 'Name': 'Hmget'}, {'Group': 'Hash', 'Cmd': 'HMSET', 'Args': 'key field value [field value ...]', 'Summary': 'Set multiple hash fields to multiple values', 'Name': 'Hmset'}, {'Group': 'Hash', 'Cmd': 'HSET', 'Args': 'key field value', 'Summary': 'Set the string value of a hash field', 'Name': 'Hset'}, {'Group': 'Hash', 'Cmd': 'HSETNX', 'Args': 'key field value', 'Summary': 'Set the value of a hash field, only if the field does not exist', 'Name': 'Hsetnx'}, {'Group': 'Hash', 'Cmd': 'HSTRLEN', 'Args': 'key field', 'Summary': 'Get the length of the value of a hash field', 'Name': 'Hstrlen'}, {'Group': 'Hash', 'Cmd': 'HVALS', 'Args': 'key', 'Summary': 'Get all the values in a hash', 'Name': 'Hvals'}, {'Group': 'Hash', 'Cmd': 'HSCAN', 'Args': 'key cursor [MATCH pattern] [COUNT count]', 'Summary': 'Incrementally iterate hash fields and associated values', 'Name': 'Hscan'}], 'Hyperloglog': [{'Group': 'Hyperloglog', 'Cmd': 'PFADD', 'Args': 'key element [element ...]', 'Summary': 'Adds the specified elements to the specified HyperLogLog.', 'Name': 'Pfadd'}, {'Group': 'Hyperloglog', 'Cmd': 'PFCOUNT', 'Args': 'key [key ...]', 'Summary': 'Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).', 'Name': 'Pfcount'}, {'Group': 'Hyperloglog', 'Cmd': 'PFMERGE', 'Args': 'destkey sourcekey [sourcekey ...]', 'Summary': 'Merge N different HyperLogLogs into a single one.', 'Name': 'Pfmerge'}], 'Pubsub': [{'Group': 'Pubsub', 'Cmd': 'PSUBSCRIBE', 'Args': 'pattern [pattern ...]', 'Summary': 'Listen for messages published to channels matching the given patterns', 'Name': 'Psubscribe'}, {'Group': 'Pubsub', 'Cmd': 'PUBSUB', 'Args': 'subcommand [argument [argument ...]]', 'Summary': 'Inspect the state of the Pub/Sub subsystem', 'Name': 'Pubsub'}, {'Group': 'Pubsub', 'Cmd': 'PUBLISH', 'Args': 'channel message', 'Summary': 'Post a message to a channel', 'Name': 'Publish'}, {'Group': 'Pubsub', 'Cmd': 'PUNSUBSCRIBE', 'Args': '[pattern [pattern ...]]', 'Summary': 'Stop listening for messages posted to channels matching the given patterns', 'Name': 'Punsubscribe'}, {'Group': 'Pubsub', 'Cmd': 'SUBSCRIBE', 'Args': 'channel [channel ...]', 'Summary': 'Listen for messages published to the given channels', 'Name': 'Subscribe'}, {'Group': 'Pubsub', 'Cmd': 'UNSUBSCRIBE', 'Args': '[channel [channel ...]]', 'Summary': 'Stop listening for messages posted to the given channels', 'Name': 'Unsubscribe'}], 'Set': [{'Group': 'Set', 'Cmd': 'SADD', 'Args': 'key member [member ...]', 'Summary': 'Add one or more members to a set', 'Name': 'Sadd'}, {'Group': 'Set', 'Cmd': 'SCARD', 'Args': 'key', 'Summary': 'Get the number of members in a set', 'Name': 'Scard'}, {'Group': 'Set', 'Cmd': 'SDIFF', 'Args': 'key [key ...]', 'Summary': 'Subtract multiple sets', 'Name': 'Sdiff'}, {'Group': 'Set', 'Cmd': 'SDIFFSTORE', 'Args': 'destination key [key ...]', 'Summary': 'Subtract multiple sets and store the resulting set in a key', 'Name': 'Sdiffstore'}, {'Group': 'Set', 'Cmd': 'SINTER', 'Args': 'key [key ...]', 'Summary': 'Intersect multiple sets', 'Name': 'Sinter'}, {'Group': 'Set', 'Cmd': 'SINTERSTORE', 'Args': 'destination key [key ...]', 'Summary': 'Intersect multiple sets and store the resulting set in a key', 'Name': 'Sinterstore'}, {'Group': 'Set', 'Cmd': 'SISMEMBER', 'Args': 'key member', 'Summary': 'Determine if a given value is a member of a set', 'Name': 'Sismember'}, {'Group': 'Set', 'Cmd': 'SMEMBERS', 'Args': 'key', 'Summary': 'Get all the members in a set', 'Name': 'Smembers'}, {'Group': 'Set', 'Cmd': 'SMOVE', 'Args': 'source destination member', 'Summary': 'Move a member from one set to another', 'Name': 'Smove'}, {'Group': 'Set', 'Cmd': 'SPOP', 'Args': 'key [count]', 'Summary': 'Remove and return one or multiple random members from a set', 'Name': 'Spop'}, {'Group': 'Set', 'Cmd': 'SRANDMEMBER', 'Args': 'key [count]', 'Summary': 'Get one or multiple random members from a set', 'Name': 'Srandmember'}, {'Group': 'Set', 'Cmd': 'SREM', 'Args': 'key member [member ...]', 'Summary': 'Remove one or more members from a set', 'Name': 'Srem'}, {'Group': 'Set', 'Cmd': 'SUNION', 'Args': 'key [key ...]', 'Summary': 'Add multiple sets', 'Name': 'Sunion'}, {'Group': 'Set', 'Cmd': 'SUNIONSTORE', 'Args': 'destination key [key ...]', 'Summary': 'Add multiple sets and store the resulting set in a key', 'Name': 'Sunionstore'}, {'Group': 'Set', 'Cmd': 'SSCAN', 'Args': 'key cursor [MATCH pattern] [COUNT count]', 'Summary': 'Incrementally iterate Set elements', 'Name': 'Sscan'}], 'SortedSet': [{'Group': 'SortedSet', 'Cmd': 'ZADD', 'Args': 'key [NX|XX] [CH] [INCR] score member [score member ...]', 'Summary': 'Add one or more members to a sorted set, or update its score if it already exists', 'Name': 'Zadd'}, {'Group': 'SortedSet', 'Cmd': 'ZCARD', 'Args': 'key', 'Summary': 'Get the number of members in a sorted set', 'Name': 'Zcard'}, {'Group': 'SortedSet', 'Cmd': 'ZCOUNT', 'Args': 'key min max', 'Summary': 'Count the members in a sorted set with scores within the given values', 'Name': 'Zcount'}, {'Group': 'SortedSet', 'Cmd': 'ZINCRBY', 'Args': 'key increment member', 'Summary': 'Increment the score of a member in a sorted set', 'Name': 'Zincrby'}, {'Group': 'SortedSet', 'Cmd': 'ZINTERSTORE', 'Args': 'destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]', 'Summary': 'Intersect multiple sorted sets and store the resulting sorted set in a new key', 'Name': 'Zinterstore'}, {'Group': 'SortedSet', 'Cmd': 'ZLEXCOUNT', 'Args': 'key min max', 'Summary': 'Count the number of members in a sorted set between a given lexicographical range', 'Name': 'Zlexcount'}, {'Group': 'SortedSet', 'Cmd': 'ZRANGE', 'Args': 'key start stop [WITHSCORES]', 'Summary': 'Return a range of members in a sorted set, by index', 'Name': 'Zrange'}, {'Group': 'SortedSet', 'Cmd': 'ZRANGEBYLEX', 'Args': 'key min max [LIMIT offset count]', 'Summary': 'Return a range of members in a sorted set, by lexicographical range', 'Name': 'Zrangebylex'}, {'Group': 'SortedSet', 'Cmd': 'ZREVRANGEBYLEX', 'Args': 'key max min [LIMIT offset count]', 'Summary': 'Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.', 'Name': 'Zrevrangebylex'}, {'Group': 'SortedSet', 'Cmd': 'ZRANGEBYSCORE', 'Args': 'key min max [WITHSCORES] [LIMIT offset count]', 'Summary': 'Return a range of members in a sorted set, by score', 'Name': 'Zrangebyscore'}, {'Group': 'SortedSet', 'Cmd': 'ZRANK', 'Args': 'key member', 'Summary': 'Determine the index of a member in a sorted set', 'Name': 'Zrank'}, {'Group': 'SortedSet', 'Cmd': 'ZREM', 'Args': 'key member [member ...]', 'Summary': 'Remove one or more members from a sorted set', 'Name': 'Zrem'}, {'Group': 'SortedSet', 'Cmd': 'ZREMRANGEBYLEX', 'Args': 'key min max', 'Summary': 'Remove all members in a sorted set between the given lexicographical range', 'Name': 'Zremrangebylex'}, {'Group': 'SortedSet', 'Cmd': 'ZREMRANGEBYRANK', 'Args': 'key start stop', 'Summary': 'Remove all members in a sorted set within the given indexes', 'Name': 'Zremrangebyrank'}, {'Group': 'SortedSet', 'Cmd': 'ZREMRANGEBYSCORE', 'Args': 'key min max', 'Summary': 'Remove all members in a sorted set within the given scores', 'Name': 'Zremrangebyscore'}, {'Group': 'SortedSet', 'Cmd': 'ZREVRANGE', 'Args': 'key start stop [WITHSCORES]', 'Summary': 'Return a range of members in a sorted set, by index, with scores ordered from high to low', 'Name': 'Zrevrange'}, {'Group': 'SortedSet', 'Cmd': 'ZREVRANGEBYSCORE', 'Args': 'key max min [WITHSCORES] [LIMIT offset count]', 'Summary': 'Return a range of members in a sorted set, by score, with scores ordered from high to low', 'Name': 'Zrevrangebyscore'}, {'Group': 'SortedSet', 'Cmd': 'ZREVRANK', 'Args': 'key member', 'Summary': 'Determine the index of a member in a sorted set, with scores ordered from high to low', 'Name': 'Zrevrank'}, {'Group': 'SortedSet', 'Cmd': 'ZSCORE', 'Args': 'key member', 'Summary': 'Get the score associated with the given member in a sorted set', 'Name': 'Zscore'}, {'Group': 'SortedSet', 'Cmd': 'ZUNIONSTORE', 'Args': 'destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]', 'Summary': 'Add multiple sorted sets and store the resulting sorted set in a new key', 'Name': 'Zunionstore'}, {'Group': 'SortedSet', 'Cmd': 'ZSCAN', 'Args': 'key cursor [MATCH pattern] [COUNT count]', 'Summary': 'Incrementally iterate sorted sets elements and associated scores', 'Name': 'Zscan'}]}
    return data
def GetArgs():
    args = ("destination key [key ...]",
            "key min max",
            "key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]",
            "key increment",
            "key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]",
            "key element [element ...]",
            "key increment member",
            "key value",
            "connection-name",
            "key start stop",
            "key seconds",
            "key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]",
            "key value [value ...]",
            "sha1 numkeys key [key ...] arg [arg ...]",
            "slot [slot ...]",
            "key bit [start] [end]",
            "slot IMPORTING|MIGRATING|STABLE|NODE [node-id]",
            "password",
            "source destination timeout",
            "channel message",
            "channel [channel ...]",
            "script",
            "key milliseconds-timestamp",
            "pattern [pattern ...]",
            "[HARD|SOFT]",
            "key BEFORE|AFTER pivot value",
            "[ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]",
            "sha1 [sha1 ...]",
            "key cursor [MATCH pattern] [COUNT count]",
            "key member1 member2 [unit]",
            "index index",
            "key index",
            "key",
            "ip port",
            "ON|OFF|SKIP",
            "key newkey",
            "key field value [field value ...]",
            "numslaves timeout",
            "destkey sourcekey [sourcekey ...]",
            "key ttl serialized-value [REPLACE]",
            "[NOSAVE|SAVE]",
            "slot count",
            "pattern",
            "key longitude latitude member [longitude latitude member ...]",
            "[section]",
            "index",
            "key [count]",
            "key [key ...]",
            "subcommand [argument]",
            "key field value",
            'host port key|"" destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]',
            "key field increment",
            "key start end",
            "timeout",
            "subcommand [argument [argument ...]]",
            "key member",
            "[channel [channel ...]]",
            "key milliseconds",
            "key field",
            "[ASYNC]",
            "key db",
            "key [NX|XX] [CH] [INCR] score member [score member ...]",
            "key max min [LIMIT offset count]",
            "key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]",
            "source destination",
            "key start stop [WITHSCORES]",
            "host port",
            "command-name [command-name ...]",
            "key index value",
            "key seconds value",
            "key [key ...] timeout",
            "slot",
            "[pattern [pattern ...]]",
            "parameter value",
            "script numkeys key [key ...] arg [arg ...]",
            "key [start end]",
            "destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]",
            "key decrement",
            "cursor [MATCH pattern] [COUNT count]",
            "key value [key value ...]",
            "source destination member",
            "key member [member ...]",
            "message",
            "[FORCE|TAKEOVER]",
            "node-id",
            "YES|SYNC|NO",
            "key min max [WITHSCORES] [LIMIT offset count]",
            "operation destkey key [key ...]",
            "key min max [LIMIT offset count]",
            "key max min [WITHSCORES] [LIMIT offset count]",
            "key timestamp",
            "parameter",
            "key milliseconds value",
            "config-epoch",
            "[message]",
            "key count value",
            "key field [field ...]",
            "key offset",
            "subcommand [arguments [arguments ...]]",
            "key value [EX seconds] [PX milliseconds] [NX|XX]",
            "key offset value",
            )
    return args